#!/usr/bin/env python2

import argparse
import json
import os
import subprocess

DEFAULT_OUT_FILENAME = 'detection_results.json'
DOWNLOADS_PATH = 'package_downloads'
DETECTION_TOOL_COMMAND = './src/mock_detection_tool.sh'

class DetectionHarness:
   def __init__(self, package_infos, start_offset):
      self._package_infos = package_infos
      self._start_offset = start_offset

      self._detection_results = []

   def run(self):
      for package_info in self._package_infos:
         # TODO(jayden): Download the package source.

         # Run the detection tool on the package.
         detection_result_string = subprocess.check_output(DETECTION_TOOL_COMMAND.split())
         self._detection_results.append(json.loads(detection_result_string))

      return self._detection_results

if __name__ == '__main__':
   parser = argparse.ArgumentParser()
   parser.add_argument('package_infos_file',
                       help=('JSON file with package infos, generated by'
                             ' package_finder'))
   parser.add_argument('--out', help="output file path, default: %s" % DEFAULT_OUT_FILENAME,
                       default=DEFAULT_OUT_FILENAME)
   parser.add_argument('--start-offset', help='package index to start at', default=0)
   args = parser.parse_args()

   # Verify package infos file exists.
   package_infos_path = os.path.join(os.getcwd(), args.package_infos_file)
   if not os.path.isfile(package_infos_path):
      sys.stderr.write('package infos file "%s" does not exist' % args.package_infos_file)
      exit(errno.ENOENT)

   # Read package infos.
   with open(package_infos_path) as f:
      package_infos = json.load(f)

   # Run detection harness.
   detection_harness = DetectionHarness(package_infos, int(args.start_offset))
   results = detection_harness.run()

   # Save results to output file.
   with open(os.path.join(os.getcwd(), args.out), 'w') as f:
      json.dump(results, f, indent=4)
      f.write('\n')
