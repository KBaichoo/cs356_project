#!/usr/bin/env python2

import argparse
import datetime
import json
import os
import shutil
import subprocess

DEFAULT_OUT_FILENAME = 'detection_results.json'
DOWNLOADS_PATH = 'package_downloads'
DETECTION_TOOL_CMD = './src/mock_detection_tool.sh %s'

class DetectionHarness:
   def __init__(self, package_infos, start_offset):
      self._package_infos = package_infos
      self._start_offset = start_offset

      self._detection_results = []

   @staticmethod
   def _download_package(download_cmd):
      # Enter download path.
      cwd = os.getcwd()
      os.chdir(DOWNLOADS_PATH)

      try:
         # Pull down source.
         subprocess.call(download_cmd.split(),
                         stdout=open(os.devnull, 'w'), stderr=subprocess.STDOUT)

         # Find source path.
         subdirs = next(os.walk('.'))[1]
         if len(subdirs) != 1:
            raise PackageError('package source could not be extracted')
      except Exception as e:
         raise e
      finally:
         # Return to earlier working directory.
         os.chdir(cwd)

      return os.path.join(os.getcwd(), DOWNLOADS_PATH, subdirs[0])

   def run(self):
      for package_info in self._package_infos[self._start_offset:]:
         (repo_name, rank, package_name) = (package_info['source'], package_info['rank'],
                                            package_info['package_name'])
         print 'Running tool on: (%s, %s, %s)' % (repo_name, rank, package_name)

         # Create the downloads directory.
         if os.path.isdir(DOWNLOADS_PATH):
            shutil.rmtree(DOWNLOADS_PATH)
         os.makedirs(DOWNLOADS_PATH)

         try:
            # Download the package source.
            package_path = self._download_package(package_info['download_cmd'])

            # Run the detection tool on the package.
            cmd = DETECTION_TOOL_CMD % package_path
            detection_result_string = subprocess.check_output(cmd.split())
            self._detection_results.append({
               'package_name': package_name,
               'version_number': package_info['version_number'],
               'data_collection_timestamp': datetime.datetime.today().strftime('%Y-%m-%d-%H:%M:%S'),
               'detection_tool_output': json.loads(detection_result_string)
            })
         except Exception as e:
            print 'Error: %s\n' % str(e)
            continue
         finally:
            # Delete the downloads directory.
            shutil.rmtree(DOWNLOADS_PATH)

         print ''

      return self._detection_results

if __name__ == '__main__':
   parser = argparse.ArgumentParser()
   parser.add_argument('package_infos_file',
                       help=('JSON file with package infos, generated by'
                             ' package_finder'))
   parser.add_argument('--out', help="output file path, default: %s" % DEFAULT_OUT_FILENAME,
                       default=DEFAULT_OUT_FILENAME)
   parser.add_argument('--start-offset', help='package index to start at', default=0)
   args = parser.parse_args()

   # Verify package infos file exists.
   package_infos_path = os.path.join(os.getcwd(), args.package_infos_file)
   if not os.path.isfile(package_infos_path):
      sys.stderr.write('package infos file "%s" does not exist' % args.package_infos_file)
      exit(errno.ENOENT)

   # Read package infos.
   with open(package_infos_path) as f:
      package_infos = json.load(f)

   # Run detection harness.
   detection_harness = DetectionHarness(package_infos, int(args.start_offset))
   results = detection_harness.run()

   # Save results to output file.
   with open(os.path.join(os.getcwd(), args.out), 'w') as f:
      json.dump(results, f, indent=4)
      f.write('\n')
